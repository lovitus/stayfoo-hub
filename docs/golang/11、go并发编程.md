# go并发编程

> Don’t communicate by sharing memory; share memory by communicating.   
> 不要通过共享内存来通信，而应该通过通信来共享内存。


- goroutine（go 协程）

- channel（通道）goroutine（go 协程）之间传递数据（通道是用来传递数据的）。

- `goroutine`和`channel`让并发变得很简单。

- `go`不推荐用共享内存的方式传递数据，而推荐使用`channel`（`通道`）。`channel`主要用来在多个`goroutine`之间传递数据，并且还会保证整个过程的并发安全性。


> `channel` 通道是一种内置的数据结构，可以让用户在不同的 `goroutine` 之间同步发送具有类型的消息。（也就是在 `goroutine` 之间发送消息，而不是让多个 `goroutine` 争夺同一个数据的使用权。）(`channel` 可以让 `goroutine` 之间安全的进行数据通信。可以避免其他语言常见共享内存访问的问题。)

> 并发的难点：要确保其他并发运行的进程、线程、`goroutine` 不会意外修改用户的数据。当不同的线程在没有同步保护的情况下修改同一个数据时，会出现灾难性的结果。在其他语言中如果使用全局变量或共享内存，必须使用复杂的锁规则来防止对同一个变量的不同步修改。

> 为了解决上面问题，通道提供了一种新模式，来保证并发修改时的数据安全。通道这一模式保证同一时刻只会有一个 `goroutine` 修改数据。通道用于在几个运行的 `goroutine` 之间发送数据。

> 注意：通道并不提供跨 `goroutine` 的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个 `goroutine` 都持有一份副本，各自对自己的副本做修改是安全的。当传输的是指向数据的指针时（所以通道中尽量不要使用指针），如果读和写是由不同的 `goroutine` 完成的，每个 `goroutine` 依旧需要额外的同步动作。 


## channel（通道）

- channel（通道）是并发安全的。

- channel（通道）是先进先出的。

- 通道底层存储数据的是环形链表。

- 通道的长度：它当前包含的元素值的个数。通道元素满的时候，长度和容量相同。
- 
- 通道的容量：初始化时，通道设置的那个值。

- 通道有两个操作：发送操作和接收操作
    - 发送操作包括两步：`复制元素值`、`放置副本到通道内部`。
    - 接收操作包括三步：`复制通道内的元素值`、`放置副本到接收方`、`删除原值`。
    - 同一个通道，所有操作（发送和接收）都是阻塞的、互斥的。
      - 多个 goroutine 同时操作同一个通道也是阻塞的。
    - GO运行时系统，同一时间对同一个通道只能执行一个操作（直到元素被完全复制进该通道，或被移出该通道）。
    - 发送操作时，复制元素值到通道不会出现只复制一部分的情况（要么还没复制，要么已经复制完毕）；接收操作也是如此，复制完元素值副本之后，一定会删除通道中的原值。
    

```
ch1 := make(chan int, 3)
ch1 <- 1
ch1 <- 2
ch1 <- 3
elem1 := <-ch1
elem2, ok := <-ch1
if ok { // false ： 通道关闭 
	fmt.Println("ch1 -> elem1:", elem1, "\telem2: ",elem2)
}
```

## 缓冲通道和非缓冲通道（channel）

- 缓冲通道：容量大于0的通道。
- 非缓冲通道：容量等于0的通道。

数据传递方式不一样。

### `发送操作`和`接收操作`被长时间阻塞

什么情况下可能被长时间阻塞?

- 缓冲通道
    - 发送操作情况：
        - 如果通道已满，那么对它的所有发送操作就会被阻塞，直到通道中有元素被接收。
        - 发送操作被阻塞后，所有发送操作所在的 goroutine 会顺序地进入通道内部的发送等待队列。
        
    - 接收操作情况：
        - 如果通道空了，那么它的所有接收操作都会被阻塞。直到通道中有新元素值出现。
        - 接收操作被阻塞后，所有接收操作所在的 goroutine 会顺序地被放入通道内部的接收等待队列。

- 非缓冲通道
    - 发送操作和接收操作一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。收发双方对接上了，数据才会被传递。（收发是同步的）
    - 数据直接从发送方复制到接收方，中间不会用非缓冲通道做中转。

- 对值为nil的通道：对他发送操作和接收操作都会永久阻塞。它们所属的 goroutine 中的任何代码都不会再执行。

### 通道操作引发 panic

- 通道已经初始化，但并未关闭，收发操作一定不会引发 panic。通道关闭，对它收发操作就会引起 panic。

- 试图关闭一个已经关闭的通道，也会引起 panic。

```
func main() {
	ch1 := make(chan int, 2)
	// 发送
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Printf("Sender: sending element %v...\n", i)
			ch1 <- i
		}
		fmt.Println("Sender: close the channel...")
		close(ch1)
	}()

	// 接收
	for {
		elem, ok := <-ch1
		if !ok {
			fmt.Println("Receiver: closed channel")
			break
		}
		fmt.Printf("Receiver: received an element: %v\n", elem)
	}

	fmt.Println("End.")
}
```

- 通道需要手动关闭，可以利用关闭的动作来给接收方传递一个信号。Go的GC只会清理被分配到堆上的、不再有任何引用的对象。

- 在发送方关闭通道，不要在接收方关闭通道。


## 单向通道

只能发不能收，或者只能收不能发。

```
//单向通道，只能发给通道
ch := make(chan<- int, 2)
```

```
//单向通道，只能从通道收
ch := make(<-chan int, 2)
```

- 单向通道作为函数入参：可以限制函数内部操作（只能收元素或发元素）。

- 单向通道作为返回值：可以限制外部代码的操作（只能收元素或发元素，一般是只能收）

- 函数入参是单向通道，可以直接传入双向通道，Go语言会自动地把双向通道转换为函数所需要的单向通道。


## select 语句与通道

select 是专为通道而设计的。

- 如果没有对应的分支选择，select 语句会被阻塞。

```
func main() {
	chs := [3]chan int {
		make(chan int, 1),
		make(chan int, 1),
		make(chan int, 1),
	}

	index := rand.Intn(3)
	fmt.Println("index: ", index)
	chs[index] <- index

	select {
	case <-chs[0]:
		fmt.Println("1 is selected.")
	case <-chs[1]:
		fmt.Println("2 is selected.")
	case <-chs[2]:
		fmt.Println("3 is selected.")
	default:
		fmt.Println("No.")
	}
}
```



